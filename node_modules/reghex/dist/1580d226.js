'use strict';
var _state = "state", _node = "node", _match = "x";
function js() {
  for (var a = arguments, e = arguments[0][0], b = 1; b < arguments.length; b++) {
    e = e + a[b] + a[0][b];
  }
  return e.trim();
}
var copy = function(a) {
  var e = {}, b;
  for (b in a) {
    e[b] = a[b];
  }
  return e;
}, assignIndex = function(a) {
  return " var y" + (a + ("=" + (_state + (".y,x" + (a + ("=" + (_state + ".x;")))))));
}, restoreIndex = function(a) {
  return _state + (".y=y" + (a + (";" + (_state + (".x=x" + (a + ";"))))));
}, astExpression = function(a, e, b) {
  e = !!b.capture && !a.capture;
  var d = b.length && b.abort && _node + (".length=ln" + (b.length + ";")) || "";
  return " if((" + (_match + " = " + a.expression.id + "(" + _state + ")) " + (e ? "!=" : "==") + " null)" + ((e ? "{" + (_node + (".push(" + (_match + ");}else "))) : "") + ("{" + (restoreIndex(b.index) + (d + (b.abort + "}"))))));
}, astGroup = function(a, e, b) {
  var d = !!b.capture && !a.capture;
  b = copy(b);
  b.capture = d;
  return !b.length && d ? (b.length = e, "var ln" + (e + ("=" + (_node + ".length;"))) + (astSequence(a.sequence, e + 1, b) + "")) : astSequence(a.sequence, e + 1, b);
}, astChild = function(a, e, b) {
  return a.expression ? astExpression(a, e, b) : astGroup(a, e, b);
}, astQuantifier = function(a, e, b) {
  var d = b.index, l = b.abort, m = "inv_" + e, g = "loop_" + e;
  b = copy(b);
  "!" === a.capture && (b.index = e, b.abort = "break " + (m + ""));
  "+" === a.quantifier ? (g = copy(a), g.quantifier = "*", b = astChild(a, e, b) + (astQuantifier(g, e, b) + "")) : "*" === a.quantifier ? (b.length = 0, b.index = e, b.abort = "break " + (g + ";"), b = g + (":for(;;){" + (assignIndex(e) + (astChild(a, e, b) + "}")))) : "?" === a.quantifier ? (b.index = e, b.abort = "", b = assignIndex(e) + (astChild(a, e, b) + "")) : b = astChild(a, e, b);
  return "!" === a.capture ? m + (":{" + (assignIndex(e) + (b + (restoreIndex(d) + (l + "}"))))) : "=" === a.capture ? assignIndex(e) + (b + (restoreIndex(e) + "")) : b;
}, astSequence = function(a, e, b) {
  for (var d = a.alternation ? "alt_" + e : "", l = ""; a; a = a.alternation) {
    var m = "block_" + e, g = b;
    a.alternation && (g = copy(b), g.index = e, g.abort = "break " + (m + ";"));
    for (var h = "", k = 0; k < a.length; k++) {
      h += astQuantifier(a[k], e, g);
    }
    l = a.alternation ? l + (m + (":{" + (assignIndex(e) + (h + (" break " + (d + ";}")))))) : l + h;
  }
  return d ? d + (":{" + (l + "}")) : l;
}, astRoot = function(a, e, b) {
  return "(function(" + (_state + ("){" + (assignIndex(1) + (" var " + (_node + ("=[];var " + (_match + (";" + (astSequence(a, 2, {index:1, length:0, abort:"return;", capture:!0}) + (_node + (".tag=" + (e + (";return " + ((b ? "(" + (b + (")(" + (_node + ")"))) : _node) + ";})"))))))))))))));
}, syntaxError = function(a) {
  throw new SyntaxError('Unexpected token "' + a + '"');
}, parse = function(a, e) {
  for (var b = [], d = [], l = null, m, g = d, h, k, c = 0; c < a.length + e.length; c++) {
    0 !== c % 2 && (k = e[c++ >> 1], g.push({expression:k, capture:h}), h = void 0);
    var n = a[c >> 1];
    for (k = 0; k < n.length;) {
      var f = n[k++];
      " " !== f && "\t" !== f && "\r" !== f && "\n" !== f && ("|" === f && g.length ? g = g.alternation = [] : ")" === f && g.length ? (l = null, (g = b.pop()) || syntaxError(f)) : "(" === f ? (b.push(g), g.push(l = {sequence:[], capture:h}), g = l.sequence, h = void 0) : ":" === f || "=" === f || "!" === f ? (h = f, n[k] && "(" !== n[k] && syntaxError(f)) : "?" === f && !g.length && l ? (h = n[k++], ":" === h || "=" === h || "!" === h ? (l.capture = h, h = void 0) : syntaxError(f)) : "?" !== f && 
      "+" !== f && "*" !== f || !(m = g[g.length - 1]) ? syntaxError(f) : m.quantifier = f);
    }
  }
  return d;
};
function _ref3(a) {
  return a.value.cooked;
}
function makeHelpers(a) {
  function e(c) {
    return d.isImportSpecifier(c) && "match" === c.imported.name;
  }
  function b(c) {
    return d.stringLiteral(c.value.cooked.replace(/\s*/g, ""));
  }
  var d = a.types, l = a.template, m = /reghex$|^reghex\/macro/, g = !1;
  d.identifier("match");
  var h = d.identifier("__pattern"), k = new Map;
  return {updateImport:function(c) {
    !g && m.test(c.node.source.value) && (g = !0, "reghex" !== c.node.source.value && (c.node.source = d.stringLiteral("reghex")), h = c.scope.generateUidIdentifier("_pattern"), c.node.specifiers.push(d.importSpecifier(h, d.identifier("__pattern"))), c.node.specifiers.find(e) || c.node.specifiers.push(d.importSpecifier(c.scope.generateUidIdentifier("match"), d.identifier("match"))));
  }, isMatch:function(c) {
    return d.isTaggedTemplateExpression(c.node) && d.isCallExpression(c.node.tag) && d.isIdentifier(c.node.tag.callee) && c.scope.hasBinding(c.node.tag.callee.name) ? (d.isVariableDeclarator(c.parentPath) && (c.parentPath._isMatch = !0), !0) : d.isVariableDeclarator(c.parentPath) && c.parentPath._isMatch;
  }, getMatchImport:function(c) {
    d.assertTaggedTemplateExpression(c.node);
    c = c.scope.getBinding(c.node.tag.callee.name);
    return "module" === c.kind && d.isImportDeclaration(c.path.parent) && m.test(c.path.parent.source.value) && d.isImportSpecifier(c.path.node) ? c.path.parentPath : null;
  }, getMatchName:function(c) {
    d.assertTaggedTemplateExpression(c.node);
    var b = c.get("tag.arguments.0"), a = b.evaluate(), e = a.confident;
    a = a.value;
    return !e && d.isIdentifier(b.node) ? b.node.name : e && "string" === typeof a ? a : c.scope.generateUidIdentifierBasedOnNode(c.node);
  }, _prepareExpressions:function(c) {
    var b = this;
    d.assertTaggedTemplateExpression(c.node);
    var a = [], e = this.getMatchName(c), g = c.node.quasi.expressions.map(function(f, g) {
      d.isArrowFunctionExpression(f) && d.isIdentifier(f.body) ? f = f.body : (d.isFunctionExpression(f) || d.isArrowFunctionExpression(f)) && d.isBlockStatement(f.body) && 1 === f.body.body.length && d.isReturnStatement(f.body.body[0]) && d.isIdentifier(f.body.body[0].argument) && (f = f.body.body[0].argument);
      if (g = d.isIdentifier(f) && c.scope.hasBinding(f.name)) {
        var n = c.scope.getBinding(f.name);
        if (d.isVariableDeclarator(n.path.node)) {
          n = n.path.get("init");
          if (b.isMatch(n)) {
            return f;
          }
          if (k.has(f.name)) {
            return d.identifier(k.get(f.name));
          }
        }
      }
      g = c.scope.generateUidIdentifier(g ? f.name + "_expression" : e + "_expression");
      a.push(d.variableDeclarator(g, d.callExpression(d.identifier(h.name), [f])));
      d.isIdentifier(f) && k.set(f.name, g.name);
      return g;
    });
    a.length && c.getStatementParent().insertBefore(d.variableDeclaration("var", a));
    return g.map(function(a) {
      var f = c.scope.getBinding(a.name);
      return f && d.isVariableDeclarator(f.path.node) && (f = f.path.get("init"), b.isMatch(f)) ? {fn:!0, id:a.name} : {fn:!1, id:d.isStringLiteral(a) ? JSON.stringify(a.value) : a.name};
    });
  }, _prepareTransform:function(c) {
    var a = c.node.tag.arguments[1];
    if (!a) {
      return null;
    }
    if (d.isIdentifier(a)) {
      return a.name;
    }
    var b = this.getMatchName(c);
    b = c.scope.generateUidIdentifier(b + "_transform");
    a = d.variableDeclarator(b, a);
    c.getStatementParent().insertBefore(d.variableDeclaration("var", [a]));
    return b.name;
  }, minifyMatch:function(a) {
    if (!a.node.tag.arguments.length) {
      throw a.get("tag").buildCodeFrameError("match() must at least be called with a node name");
    }
    var c = a.node.quasi.quasis.map(b), f = a.node.quasi.expressions;
    this._prepareTransform(a);
    a.replaceWith(d.callExpression(a.node.tag, [d.arrayExpression(c)].concat(f)));
  }, transformMatch:function(a) {
    if (!a.node.tag.arguments.length) {
      throw a.get("tag").buildCodeFrameError("match() must at least be called with a node name");
    }
    var b = a.node.tag.arguments[0], c = a.node.quasi.quasis.map(_ref3), d = this._prepareExpressions(a), e = this._prepareTransform(a);
    try {
      var g = parse(c, d);
    } catch (p) {
      if ("SyntaxError" !== p.name) {
        throw p;
      }
      throw a.get("quasi").buildCodeFrameError(p.message);
    }
    c = astRoot(g, "%%name%%", e && "%%transform%%");
    a.replaceWith(l.expression(c)(e ? {name:b, transform:e} : {name:b}));
  }};
}
exports.makeHelpers = makeHelpers

//# sourceMappingURL=1580d226.js.map
