"use strict";
/* IMPORT */
const fs = require("fs");
const path = require("path");
const promise_concurrency_limiter_1 = require("promise-concurrency-limiter");
/* HELPERS */
const limiter = new promise_concurrency_limiter_1.default({ concurrency: 500 });
/* TINY READDIR */
const readdir = (rootPath, options) => {
    var _a, _b, _c, _d;
    const followSymlinks = (_a = options === null || options === void 0 ? void 0 : options.followSymlinks) !== null && _a !== void 0 ? _a : false, maxDepth = (_b = options === null || options === void 0 ? void 0 : options.depth) !== null && _b !== void 0 ? _b : Infinity, isIgnored = (_c = options === null || options === void 0 ? void 0 : options.ignore) !== null && _c !== void 0 ? _c : (() => false), signal = (_d = options === null || options === void 0 ? void 0 : options.signal) !== null && _d !== void 0 ? _d : { aborted: false }, directories = [], files = [], symlinks = [], resultEmpty = { directories: [], files: [], symlinks: [] }, result = { directories, files, symlinks };
    const handleDirectory = (subPath, depth) => {
        directories.push(subPath);
        if (depth >= maxDepth)
            return;
        return limiter.add(() => populateResult(subPath, depth + 1));
    };
    const handleFile = (subPath) => {
        files.push(subPath);
    };
    const handleSymlink = (subPath, depth) => {
        symlinks.push(subPath);
        if (!followSymlinks)
            return;
        if (depth >= maxDepth)
            return;
        return limiter.add(async () => {
            try {
                const realPath = await fs.promises.realpath(subPath), stat = await fs.promises.stat(realPath);
                await handleStat(realPath, stat, depth + 1);
            }
            catch (_a) { }
        });
    };
    const handleStat = (rootPath, stat, depth) => {
        if (signal.aborted)
            return;
        if (isIgnored(rootPath))
            return;
        if (stat.isDirectory()) {
            return handleDirectory(rootPath, depth);
        }
        else if (stat.isFile()) {
            return handleFile(rootPath);
        }
        else if (stat.isSymbolicLink()) {
            return handleSymlink(rootPath, depth);
        }
    };
    const handleDirent = (rootPath, dirent, depth) => {
        if (signal.aborted)
            return;
        const subPath = path.resolve(rootPath, dirent.name);
        if (isIgnored(subPath))
            return;
        if (dirent.isDirectory()) {
            return handleDirectory(subPath, depth);
        }
        else if (dirent.isFile()) {
            return handleFile(subPath);
        }
        else if (dirent.isSymbolicLink()) {
            return handleSymlink(subPath, depth);
        }
    };
    const handleDirents = (rootPath, dirents, depth) => {
        return Promise.all(dirents.map((dirent) => {
            return handleDirent(rootPath, dirent, depth);
        }));
    };
    const populateResult = async (rootPath, depth) => {
        if (signal.aborted)
            return;
        if (depth > maxDepth)
            return;
        const dirents = await fs.promises.readdir(rootPath, { withFileTypes: true }).catch(() => []);
        if (signal.aborted)
            return;
        if (!dirents.length)
            return;
        await handleDirents(rootPath, dirents, depth);
    };
    const getResult = async (rootPath, depth = 1) => {
        await populateResult(rootPath, depth);
        if (signal.aborted)
            return resultEmpty;
        return result;
    };
    return getResult(rootPath);
};
/* EXPORT */
module.exports = readdir;
module.exports.default = readdir;
Object.defineProperty(module.exports, "__esModule", { value: true });
